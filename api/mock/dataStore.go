// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dp-legacy-cache-api/api"
	"github.com/ONSdigital/dp-legacy-cache-api/models"
	"sync"
)

// Ensure, that DataStoreMock does implement api.DataStore.
// If this is not the case, regenerate this file with moq.
var _ api.DataStore = &DataStoreMock{}

// DataStoreMock is a mock implementation of api.DataStore.
//
//	func TestSomethingThatUsesDataStore(t *testing.T) {
//
//		// make and configure a mocked api.DataStore
//		mockedDataStore := &DataStoreMock{
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			GetDataSetsFunc: func(ctx context.Context) ([]models.DataMessage, error) {
//				panic("mock out the GetDataSets method")
//			},
//			IsConnectedFunc: func(ctx context.Context) bool {
//				panic("mock out the IsConnected method")
//			},
//			NewMongoStoreFunc: func(ctx context.Context) error {
//				panic("mock out the NewMongoStore method")
//			},
//		}
//
//		// use mockedDataStore in code that requires api.DataStore
//		// and then make assertions.
//
//	}
type DataStoreMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// GetDataSetsFunc mocks the GetDataSets method.
	GetDataSetsFunc func(ctx context.Context) ([]models.DataMessage, error)

	// IsConnectedFunc mocks the IsConnected method.
	IsConnectedFunc func(ctx context.Context) bool

	// NewMongoStoreFunc mocks the NewMongoStore method.
	NewMongoStoreFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetDataSets holds details about calls to the GetDataSets method.
		GetDataSets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// IsConnected holds details about calls to the IsConnected method.
		IsConnected []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NewMongoStore holds details about calls to the NewMongoStore method.
		NewMongoStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockClose         sync.RWMutex
	lockGetDataSets   sync.RWMutex
	lockIsConnected   sync.RWMutex
	lockNewMongoStore sync.RWMutex
}

// Close calls CloseFunc.
func (mock *DataStoreMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("DataStoreMock.CloseFunc: method is nil but DataStore.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedDataStore.CloseCalls())
func (mock *DataStoreMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetDataSets calls GetDataSetsFunc.
func (mock *DataStoreMock) GetDataSets(ctx context.Context) ([]models.DataMessage, error) {
	if mock.GetDataSetsFunc == nil {
		panic("DataStoreMock.GetDataSetsFunc: method is nil but DataStore.GetDataSets was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetDataSets.Lock()
	mock.calls.GetDataSets = append(mock.calls.GetDataSets, callInfo)
	mock.lockGetDataSets.Unlock()
	return mock.GetDataSetsFunc(ctx)
}

// GetDataSetsCalls gets all the calls that were made to GetDataSets.
// Check the length with:
//
//	len(mockedDataStore.GetDataSetsCalls())
func (mock *DataStoreMock) GetDataSetsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetDataSets.RLock()
	calls = mock.calls.GetDataSets
	mock.lockGetDataSets.RUnlock()
	return calls
}

// IsConnected calls IsConnectedFunc.
func (mock *DataStoreMock) IsConnected(ctx context.Context) bool {
	if mock.IsConnectedFunc == nil {
		panic("DataStoreMock.IsConnectedFunc: method is nil but DataStore.IsConnected was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockIsConnected.Lock()
	mock.calls.IsConnected = append(mock.calls.IsConnected, callInfo)
	mock.lockIsConnected.Unlock()
	return mock.IsConnectedFunc(ctx)
}

// IsConnectedCalls gets all the calls that were made to IsConnected.
// Check the length with:
//
//	len(mockedDataStore.IsConnectedCalls())
func (mock *DataStoreMock) IsConnectedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockIsConnected.RLock()
	calls = mock.calls.IsConnected
	mock.lockIsConnected.RUnlock()
	return calls
}

// NewMongoStore calls NewMongoStoreFunc.
func (mock *DataStoreMock) NewMongoStore(ctx context.Context) error {
	if mock.NewMongoStoreFunc == nil {
		panic("DataStoreMock.NewMongoStoreFunc: method is nil but DataStore.NewMongoStore was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNewMongoStore.Lock()
	mock.calls.NewMongoStore = append(mock.calls.NewMongoStore, callInfo)
	mock.lockNewMongoStore.Unlock()
	return mock.NewMongoStoreFunc(ctx)
}

// NewMongoStoreCalls gets all the calls that were made to NewMongoStore.
// Check the length with:
//
//	len(mockedDataStore.NewMongoStoreCalls())
func (mock *DataStoreMock) NewMongoStoreCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNewMongoStore.RLock()
	calls = mock.calls.NewMongoStore
	mock.lockNewMongoStore.RUnlock()
	return calls
}
