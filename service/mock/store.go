// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dp-healthcheck/healthcheck"
	"github.com/ONSdigital/dp-legacy-cache-api/api"
	"github.com/ONSdigital/dp-legacy-cache-api/models"
	"sync"
	"time"
)

// Ensure, that DataStoreMock does implement api.DataStore.
// If this is not the case, regenerate this file with moq.
var _ api.DataStore = &DataStoreMock{}

// DataStoreMock is a mock implementation of api.DataStore.
//
//	func TestSomethingThatUsesDataStore(t *testing.T) {
//
//		// make and configure a mocked api.DataStore
//		mockedDataStore := &DataStoreMock{
//			CheckerFunc: func(ctx context.Context, state *healthcheck.CheckState) error {
//				panic("mock out the Checker method")
//			},
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			GetCacheTimeFunc: func(ctx context.Context, id string) (*models.CacheTime, error) {
//				panic("mock out the GetCacheTime method")
//			},
//			GetCacheTimesFunc: func(ctx context.Context, offset int, limit int, releaseTime time.Time) (*[]models.CacheTime, int, error) {
//				panic("mock out the GetCacheTimes method")
//			},
//			IsConnectedFunc: func(ctx context.Context) bool {
//				panic("mock out the IsConnected method")
//			},
//			UpsertCacheTimeFunc: func(ctx context.Context, cacheTime *models.CacheTime) error {
//				panic("mock out the UpsertCacheTime method")
//			},
//		}
//
//		// use mockedDataStore in code that requires api.DataStore
//		// and then make assertions.
//
//	}
type DataStoreMock struct {
	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, state *healthcheck.CheckState) error

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// GetCacheTimeFunc mocks the GetCacheTime method.
	GetCacheTimeFunc func(ctx context.Context, id string) (*models.CacheTime, error)

	// GetCacheTimesFunc mocks the GetCacheTimes method.
	GetCacheTimesFunc func(ctx context.Context, offset int, limit int, releaseTime time.Time) (*[]models.CacheTime, int, error)

	// IsConnectedFunc mocks the IsConnected method.
	IsConnectedFunc func(ctx context.Context) bool

	// UpsertCacheTimeFunc mocks the UpsertCacheTime method.
	UpsertCacheTimeFunc func(ctx context.Context, cacheTime *models.CacheTime) error

	// calls tracks calls to the methods.
	calls struct {
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// State is the state argument value.
			State *healthcheck.CheckState
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetCacheTime holds details about calls to the GetCacheTime method.
		GetCacheTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetCacheTimes holds details about calls to the GetCacheTimes method.
		GetCacheTimes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// ReleaseTime is the releaseTime argument value.
			ReleaseTime time.Time
		}
		// IsConnected holds details about calls to the IsConnected method.
		IsConnected []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpsertCacheTime holds details about calls to the UpsertCacheTime method.
		UpsertCacheTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CacheTime is the cacheTime argument value.
			CacheTime *models.CacheTime
		}
	}
	lockChecker         sync.RWMutex
	lockClose           sync.RWMutex
	lockGetCacheTime    sync.RWMutex
	lockGetCacheTimes   sync.RWMutex
	lockIsConnected     sync.RWMutex
	lockUpsertCacheTime sync.RWMutex
}

// Checker calls CheckerFunc.
func (mock *DataStoreMock) Checker(ctx context.Context, state *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("DataStoreMock.CheckerFunc: method is nil but DataStore.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}{
		Ctx:   ctx,
		State: state,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, state)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//
//	len(mockedDataStore.CheckerCalls())
func (mock *DataStoreMock) CheckerCalls() []struct {
	Ctx   context.Context
	State *healthcheck.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *DataStoreMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("DataStoreMock.CloseFunc: method is nil but DataStore.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedDataStore.CloseCalls())
func (mock *DataStoreMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetCacheTime calls GetCacheTimeFunc.
func (mock *DataStoreMock) GetCacheTime(ctx context.Context, id string) (*models.CacheTime, error) {
	if mock.GetCacheTimeFunc == nil {
		panic("DataStoreMock.GetCacheTimeFunc: method is nil but DataStore.GetCacheTime was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetCacheTime.Lock()
	mock.calls.GetCacheTime = append(mock.calls.GetCacheTime, callInfo)
	mock.lockGetCacheTime.Unlock()
	return mock.GetCacheTimeFunc(ctx, id)
}

// GetCacheTimeCalls gets all the calls that were made to GetCacheTime.
// Check the length with:
//
//	len(mockedDataStore.GetCacheTimeCalls())
func (mock *DataStoreMock) GetCacheTimeCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetCacheTime.RLock()
	calls = mock.calls.GetCacheTime
	mock.lockGetCacheTime.RUnlock()
	return calls
}

// GetCacheTimes calls GetCacheTimesFunc.
func (mock *DataStoreMock) GetCacheTimes(ctx context.Context, offset int, limit int, releaseTime time.Time) (*[]models.CacheTime, int, error) {
	if mock.GetCacheTimesFunc == nil {
		panic("DataStoreMock.GetCacheTimesFunc: method is nil but DataStore.GetCacheTimes was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Offset      int
		Limit       int
		ReleaseTime time.Time
	}{
		Ctx:         ctx,
		Offset:      offset,
		Limit:       limit,
		ReleaseTime: releaseTime,
	}
	mock.lockGetCacheTimes.Lock()
	mock.calls.GetCacheTimes = append(mock.calls.GetCacheTimes, callInfo)
	mock.lockGetCacheTimes.Unlock()
	return mock.GetCacheTimesFunc(ctx, offset, limit, releaseTime)
}

// GetCacheTimesCalls gets all the calls that were made to GetCacheTimes.
// Check the length with:
//
//	len(mockedDataStore.GetCacheTimesCalls())
func (mock *DataStoreMock) GetCacheTimesCalls() []struct {
	Ctx         context.Context
	Offset      int
	Limit       int
	ReleaseTime time.Time
} {
	var calls []struct {
		Ctx         context.Context
		Offset      int
		Limit       int
		ReleaseTime time.Time
	}
	mock.lockGetCacheTimes.RLock()
	calls = mock.calls.GetCacheTimes
	mock.lockGetCacheTimes.RUnlock()
	return calls
}

// IsConnected calls IsConnectedFunc.
func (mock *DataStoreMock) IsConnected(ctx context.Context) bool {
	if mock.IsConnectedFunc == nil {
		panic("DataStoreMock.IsConnectedFunc: method is nil but DataStore.IsConnected was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockIsConnected.Lock()
	mock.calls.IsConnected = append(mock.calls.IsConnected, callInfo)
	mock.lockIsConnected.Unlock()
	return mock.IsConnectedFunc(ctx)
}

// IsConnectedCalls gets all the calls that were made to IsConnected.
// Check the length with:
//
//	len(mockedDataStore.IsConnectedCalls())
func (mock *DataStoreMock) IsConnectedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockIsConnected.RLock()
	calls = mock.calls.IsConnected
	mock.lockIsConnected.RUnlock()
	return calls
}

// UpsertCacheTime calls UpsertCacheTimeFunc.
func (mock *DataStoreMock) UpsertCacheTime(ctx context.Context, cacheTime *models.CacheTime) error {
	if mock.UpsertCacheTimeFunc == nil {
		panic("DataStoreMock.UpsertCacheTimeFunc: method is nil but DataStore.UpsertCacheTime was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		CacheTime *models.CacheTime
	}{
		Ctx:       ctx,
		CacheTime: cacheTime,
	}
	mock.lockUpsertCacheTime.Lock()
	mock.calls.UpsertCacheTime = append(mock.calls.UpsertCacheTime, callInfo)
	mock.lockUpsertCacheTime.Unlock()
	return mock.UpsertCacheTimeFunc(ctx, cacheTime)
}

// UpsertCacheTimeCalls gets all the calls that were made to UpsertCacheTime.
// Check the length with:
//
//	len(mockedDataStore.UpsertCacheTimeCalls())
func (mock *DataStoreMock) UpsertCacheTimeCalls() []struct {
	Ctx       context.Context
	CacheTime *models.CacheTime
} {
	var calls []struct {
		Ctx       context.Context
		CacheTime *models.CacheTime
	}
	mock.lockUpsertCacheTime.RLock()
	calls = mock.calls.UpsertCacheTime
	mock.lockUpsertCacheTime.RUnlock()
	return calls
}
